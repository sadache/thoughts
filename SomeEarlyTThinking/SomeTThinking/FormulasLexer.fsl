{
module FormulasLexer
open System
open System.Globalization
open FormulasParser
open Microsoft.FSharp.Text.Lexing

let lexeme  = LexBuffer<_>.LexemeString

}

// These are some regular expression definitions
let digit = ['0'-'9']
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')

rule tokenize = parse
| whitespace	{ tokenize lexbuf }
| newline       { tokenize lexbuf }
// Operators
| "("			{ LPAREN }
| ")"			{ RPAREN }
| "+"			{ PLUS }
| "-"			{ MINUS }
| "*"			{ ASTER }
| "min"			{ MIN }
| "="			{ EQUALS }
| "<="			{LESS_OR_EQUALS}
| ">="			{GREATER_OR_EQUALS}
| ">"			{ GREATER_THAN }
| "<"			{ LESS_THAN}
| "\ooo/"		{CHILDREN} //like Sum( \ooo/ &RENT)
//| "/"			{ SLASH }
//Conditionals
| "if"			{IF}
| "then"		{THEN}
| "else"		{ELSE}
//Conditionals
| "year"		{YEAR}
| "month"		{MONTH}
//for transitions
|"previousMonth" 		{PREVIOUS_MONTH}
|"previousYear"		{PREVIOUS_YEAR}
|":"				{COLON}


// Numberic constants
//| ['-']?digit+  { INT32 (Int32.Parse(lexeme lexbuf)) }
| ['-']?digit+('.'digit+)?(['e''E']digit+)?   { FLOAT (Double.Parse(lexeme lexbuf,CultureInfo.InvariantCulture.NumberFormat)) }
//Boolean constants
| "true"			{BOOL(true)}
| "false"			{BOOL(false)}

// Cell References
| ['&']['A'-'Z''_']+    {REF (lexeme lexbuf)}
| eof   { EOF }
