%{
open System
%}

// The start token becomes a parser function in the compiled code:
%start start

// These are the terminal tokens of the grammar along with the types of
// the data carried by each token:
//%token <System.Int32> INT32 
%token <System.Double> FLOAT
%token <System.Boolean> BOOL
%token <System.String> REF
%token YEAR MONTH
%token PLUS MINUS ASTER	SLASH CHILDREN
%token EQUALS LESS_OR_EQUALS GREATER_OR_EQUALS GREATER_THAN LESS_THAN
%token LPAREN RPAREN
%token IF THEN ELSE
%token EOF
%left IF THEN ELSE
%left CHILDREN
%nonassoc EQUALS LESS_OR_EQUALS GREATER_OR_EQUALS GREATER_THAN LESS_THAN
%left PLUS MINUS 
%left ASTER	SLASH



// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < Exp > start 

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  In this case the actions 
// produce data using F# data construction terms.
start: Prog { $1 }

Prog:
	| Expr EOF					{ $1 }

Expr: 
	| LPAREN Expr RPAREN        { $2 }
    | Expr PLUS Expr			{ BinaryExp(DoubleOp Plus,$1, $3) }
    | Expr MINUS Expr			{  BinaryExp(DoubleOp Minus,$1, $3) }
    | Expr ASTER Expr			{  BinaryExp(DoubleOp Times,$1, $3) }
	//| Expr SLASH Expr			{  BinaryExp(DoubleOp Divide,$1, $3) }
	| Expr EQUALS Expr			{ BinaryExp(ComparaOp Equals,$1, $3) }
    | Expr GREATER_OR_EQUALS Expr			{  BinaryExp(ComparaOp GreaterOrEq,$1, $3) }
    | Expr GREATER_THAN Expr			{  BinaryExp(ComparaOp Greater,$1, $3) }

	| IF Expr THEN Expr ELSE Expr  { If($2 , $4 , $6) }
	| CHILDREN Expr				{ Children(Sum, $2) }
	| REF						{Ref ($1.Substring(1),id)}
	| FLOAT						{ Const($1) }
	//| INT32						{ Const($1) }
	| BOOL						{ConstB($1)}
	| YEAR						{Context Year}
	| MONTH						{Context Month}
